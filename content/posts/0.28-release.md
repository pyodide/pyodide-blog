---
title: "Pyodide 0.28 Release"
date: 2025-06-30
draft: true
tags: ["announcement"]
author: ["Gyeongjae Choi", "Hood Chatham", "Agriya Khetarpal"] # multiple authors
showToc: true
TocOpen: false
draft: false
hidemeta: false
comments: false
# canonicalURL: "https://canonical.url/to/page"
disableHLJS: true # to disable highlightjs
disableShare: false
hideSummary: false
searchHidden: true
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
cover:
    # image: "<image path/url>" # image path/url
    # alt: "<alt text>" # alt text
    # caption: "<text>" # display caption under cover
    relative: false # when using page bundles set this to true
    hidden: true # only hide on current single page
---

We are pleased to announce the Pyodide v0.28.0 release.

This release focused on standardizing the Pyodide platform.

## Defining the Pyodide ABI

In October 2024, the CPython steering council [approved restoring Emscripten as
a tier 3 target for
CPython](https://github.com/python/steering-council/issues/256), starting from
Python 3.14. We wrote
[PEP 776 – Emscripten Runtime support](https://peps.python.org/pep-0776/)
and
[PEP 783 – Emscripten Packaging](https://peps.python.org/pep-0783/)
in order to standardize the Emscripten target for Python.

PEP 783 aims to standardize the binary interfaces that Pyodide packages should
follow, helping ensure compatibility with current and future versions of
Pyodide. Our plan is to have one ABI per Python version. This means that
packages built for a particular version of Pyodide will be compatible with all
Pyodide versions that have the same version of Python.

As part of this effort, we gave a definition of the Pyodide ABI
[here](https://pyodide.org/en/stable/development/abi.html). This should help
people using their own build tooling to ensure that they are compatible. Of
course, most people will continue to use `pyodide-build`.

This is a crucial step towards enabling the Pyodide ecosystem to develop with
greater independence from Pyodide runtime releases. If PEP 783 is approved, we
will also be allowed to upload Pyodide packages to PyPI.

### Building Binary Packages Compatible with the Pyodide ABI

Building a package with `pyodide-build` or `cibuildwheel` will automatically
produce ABI-compliant packages (or fail to build). If you use custom build
toolchains, such as `maturin` for Rust projects, please consult the [Pyodide ABI
documentation](https://github.com/pyodide/pyodide/blob/main/docs/development/abi.md)
to ensure your packages meet the necessary compatibility standards.

## Decoupling packages from the Pyodide runtime

Pyodide is a Python distribution, which means it includes a set of pre-built
packages that are deployed together with the Pyodide runtime. In Pyodide's early
stages, this approach was practical due to the challenges of getting packages to
run in the browser, ensuring that all components were built and tested together.

However, as both the Pyodide and WebAssembly ecosystems have matured, this
integrated approach has become less sustainable:

From a user perspective, accessing packages not included in the Pyodide
distribution often meant waiting for the next Pyodide release, a process that
could take several months.

From a maintainer perspective, every commit to the Pyodide runtime repository
triggered a rebuild and retest of over 250 packages. Even a minor code change
could result in a Continuous Integration (CI) run exceeding four hours.

In this release, we've taken a significant step by unvendoring packages from the
Pyodide runtime repository.

All packages are now built in a separate repository,
[pyodide/pyodide-recipes](https://github.com/pyodide/pyodide-recipes). The main
Pyodide runtime repository now contains only the packages that are essential for
testing the runtime. This modification will enable us to release sets of
packages separately and more frequently, independent of the Pyodide runtime's
release schedule.

In the future, we are hoping that PEP 783 will be approved so people can upload
their Pyodide wheels to PyPI and use them from there.

## Python 3.13 support and disabled packages

Pyodide 0.28.0 is built with Python 3.13 and a new ABI based on Emscripten
4.0.9.

Some packages that were previously included in Pyodide 0.27.X are disabled in
Pyodide 0.28.0. Most of these are disabled because the wheel we used for Pyodide
0.27 was built externally to our tools by the package maintainers and we are
waiting on them to build a new version.

The following packages are disabled because we are waiting on their maintainers
to build a version for the updated ABI:

- arro3-compute
- arro3-core
- arro3-io
- duckdb
- osqp
- polars
- pyarrow

The following packages are disabled for other reasons:

- cartopy
- gensim
- geopandas
- pygame-ce
- pyproj
- zarr

These packages will be re-enabled when we can resolve the issues with them. We
welcome contributions from the community to help us with this.

## New matplotlib backend for Pyodide

For years, Pyodide relied on a custom Matplotlib backend (`wasm_backend`) to
render plots directly in your browser. This backend was developed by the creator
of Pyodide, Michael Droettboom, who was also a core developer of matplotlib.

However, it hadn't been maintained for a long time, and without dedicated
expertise among our core developers, it became increasingly incompatible with
newer Matplotlib versions. This made it tough to keep up with new features and
critical bug fixes.

In this release, we have deprecated these custom backend, and replaced it with
the new patched version of the `webagg` backend, which is one of the official
matplotlib backends. This new backend provides a more stable and feature-rich
experience for rendering matplotlib plots in the browser.

A huge thank you to [Ian Thomas](https://github.com/ianthomas23), a core
Matplotlib developer and JupyterLite maintainer, who is now maintaining this new
backend.

## Other improvements

### Standardized Package Loading with Runtime Paths

This release introduces support for runtime paths in Emscripten modules, which
allows us to correctly locate shared library dependencies.

If a Python binary extension `somebinmod.so` depends on a shared library,
`libsomedep.so`, this information will be included in the dynamic loader section
of `somebindmod.so`. The dynamic loader will search for `libsomedep.so` on the
`LD_LIBRARY_PATH`.

Python wheels vendor their shared libraries, so if `somebinmod.so` is contained
in `somepackage` then `somepackage.whl` will include a folder called
`somepackage.libs` with `libsomedep.so` inside. However, `somepackage.libs`
cannot be added to the `LD_LIBRARY_PATH` because we only want to search that
directory when opening shared libraries in `somepackage`.

Instead, each dynamic library has its own dependency search path called the
runtime path. This is information included in the dynamic loader section of a
shared library indicating where its dependencies should be located. In this
case, `somebinmod.so` would have an entry saying to look in `somepackage.libs`
for its dependencies.

Previously, WebAssembly shared libraries files did not support runtime paths, so
we had to use a custom patch for the Emscripten dynamic loader to apply the rule
that `somepackage.libs` should be searched when loading libraries from
`somepackage`. This patch exposed us to extra bugs and prevented us from being
able to upstream fixes to the Emscripten dynamic loader. It also forced us to
load dynamic libraries eagerly rather than lazily.

We added runtime path to the WebAssembly specification for the shared library
format, to the llvm WebAssembly object parser and linker, and to the `emcc`
linker. We also updated the dynamic loader to use this information. Finally, we
updated `pyodide-build` to emit the new runtime path data and we removed our
patch to the dynamic loader.

### Increased Adoption of JavaScript Promise Integration

JavaScript Promise Integration (JSPI) officially became a Stage 4 finished
proposal on April 8, 2025, and Chrome 137 (released May 27, 2025) now supports
JSPI by default, no experimental flag needed.

Pyodide has been a long-time experimenter with JSPI. We turned on several key
JSPI features by default in Pyodide 0.27.7. This means you can now use
`asyncio.run()` and `loop.run_until_complete()` in Pyodide to execute Python
code in the browser to block for asynchronous operations. Previously, this
capability was gated by the `enableRunUntilComplete` flag in `loadPyodide()`.
Now, if your browser supports JSPI, these features are enabled automatically.
See [our blog post about JSPI](https://blog.pyodide.org/posts/jspi/) for more
information.

## Community spotlight: Pyodide in the wild

### SPy: statically typed Python

- New collaborative work on early-stage in-browser statically typed Python for
graphics or computationally heavy use cases:
https://lukasz.langa.pl/f37aa97a-9ea3-4aeb-b6a0-9daeea5a7505/

### Interactive documentation via CZI grant to Scientific Python

- Wrapping up work on Pyodide interoperability and in-browser documentation for
  Scientific Python libraries via
  https://blog.scientific-python.org/scientific-python/2022-czi-grant/

## Acknowledgements

We appreciate the continued support the Emscripten team, particularly from Sam
Clegg. We also appreciate the support from the CPython team, particularly from
Russell Keith-Magee and Lukasz Langa.

A special thanks to Ian Thomas for his work on the new Matplotlib backend.

Thanks to all the contributors who made this release possible: <...list of contributors...>
