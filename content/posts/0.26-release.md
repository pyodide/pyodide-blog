---
title: "Pyodide 0.26 Release"
date: 2024-05-13T11:00:55-04:00
draft: true
tags: ["announcement"]
# author: "Me"
author: ["Hood Chatham", "Gyeongjae Choi"] # multiple authors
showToc: true
TocOpen: false
draft: false
hidemeta: false
comments: false
# canonicalURL: "https://canonical.url/to/page"
disableHLJS: true # to disable highlightjs
disableShare: false
hideSummary: false
searchHidden: true
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
cover:
    # image: "<image path/url>" # image path/url
    # alt: "<alt text>" # alt text
    # caption: "<text>" # display caption under cover
    relative: false # when using page bundles set this to true
    hidden: true # only hide on current single page
---

Pyodide v0.26.0 is out with Python 3.12. We made a lot of minor improvements to
the FFI and to the build system, and we made major improvements to stack
switching support. Most of the changes we made for this release are forward
looking, either nonfunctional work on maintenance, or functional work that is
still not exposed to the end user.

## Pyodide at PyCon

We were at PyCon again this year at another WebAssembly summit. The authors of
this post met each other in person for the first time. Gyeongjae's travel was
generously paid for by our sponsors, so thank you if you have ever donated to
Pyodide. Pyodide creator Mike Droettboem was there too. Both the WebAssembly
summit and the rest of PyCon went fantastically well. It was wonderful hearing
from the community about all the things that are working well for them, and also
very helpful to learn where there are needs that we are not meeting.

![](pyodide-maintainers-at-wasm-summit.jpg "Pyodide maintainers and creator at Pycon Wasm Summit")
*Left to right: Pyodide maintainer Gyeongjae Choi, Pyodide creator Mike
Droettboom, Pyodide maintainer Hood Chatham*

## Package build system

We have made significant progress in separating our package build system
(`pyodide-build`) from the Pyodide runtime. This change will not be
obviously noticeable to regular Pyodide users, it is a crucial improvement for
several reasons:

1. __Faster Package Updates__:

Currently, pyodide-build is released in conjunction with the Pyodide runtime and
the Pyodide foreign function interface, with a quarterly release cadence. This
is inconvenient for users building packages out-of-tree because they have to
wait months to use new features or bug fixes in pyodide-build. Decoupling
pyodide-build from Pyodide runtime releases will allow us to make improvements
available faster.

2. __Faster and Easier Runtime and FFI Releases__:

Because packages can only be updated once a quarter, whenever we feel that we
are ready to release a set of changes to the runtime and foreign function
interface, we feel the need to try to update as many packages as possible so
that people won't have to wait even longer to get new stable package versions.
This significantly delays releases.

3. __Decoupling Versions__: 

`pyodide-build` and the Pyodide runtime were tightly coupled, requiring users to
match their versions to build packages. This prevented users of older Pyodide
runtimes from benefiting from improvements in pyodide-build. With this change,
users will have more flexibility to use the latest version of pyodide-build.

4. __Capacity for More Packages__:

The 250+ packages in the Pyodide distribution are rebuilt with every new commit
to Pyodide. This is a heavy burden on our CI system and makes it challenging to
support additional large packages. If we had to pay for our CI resources, we
would pay over $3,000 per month. CircleCI generously donates much more to us
than they claim they are willing to.

By separating pyodide-build and the package recipes from the Pyodide runtime, we
will be able to build packages independently, allowing us to include many more
packages in the Pyodide ecosystem. It will also make the ecosystem more
sustainable in its consumption of both computational power and maintenance
effort. As part of this effort, many scientific Python packages are now building
wheels targeting Pyodide in their repositories. Thanks to Agriya Khetarpal
(@agriyakhetarpal) and Ralf Gommers (@rgommers) for this effort and thanks to
their employer Quansight for funding the work. We are also in the process of
adding Pyodide targets to cibuildwheel, which should make it much easier for
package maintainers to build wheels for Pyodide. 

[The pull request](https://github.com/pypa/cibuildwheel/pull/1456) implementing
Pyodide support in cibuildwheel has been open for 14 months and currently has 3
contributors, 175 comments from 10 people, and has been through about five
rounds of review. It feels like we are close to merging it, which will be an
incredible milestone for Pyodide. We could hardly have imagined getting to where
we are now when we took over the Pyodide project from Mozilla in April of 2021.

This work is not yet complete, but we believe it will be done by the end of the
year.

## Improved documentation automation maintainability

We did a major rewrite of part of `sphinx-js`, moving the logic for ingesting the
typedoc ast from Python to JavaScript. In the process of doing this we discovered
and fixed a large number of bugs. It is now dramatically easier to implement new
features and to update dependencies than it ever was before. We were able to fix
most of the remaining complaints we had about the rendering of Pyodide's JS API
docs. (The content itself still has a lot of issues though.)

## Improvements to Stack Switching Support

Stack switching allows us to make async calls from a synchronous Python
function. For example:
```js
py.runPythonAsync(`
from js import fetch
from pyodide.ffi import run_sync

def sync_fetch(url):
  resp = run_sync(fetch(url))
  text = run_sync(resp.text())
  return text

print(sync_fetch("https://example.com"))
`);
```

We fixed quite a few memory leaks involving stack switching, improved the
interactions with certain other language features, and polished the API.
Stack switching is ready for real-world use at this point. 

There are a lot of usability improvements left to build. For instance, we could
use it to implement `loop.run_until_complete()`, to make pdb work, to make http
clients work, and many more things.

Chrome has started the 
[JSPI origin trial](https://developer.chrome.com/blog/webassembly-jspi-origin-trial)
so if you want to use stack switching in your web app you can add your domain to
the origin trial. It is also possible to use in node v20 if you pass `--experimental-wasm-stack-switching` to node.

## Load time optimization: Memory snapshots

Pyodide does a lot of work at startup time initializing the Python interpreter,
importing expensive Python packages like asyncio, etc. This work is done every
time at startup and is quite wasteful. Ideally we should be able to avoid
redoing this work every startup.

There are two main approaches to reducing startup work. One approach is compile
time or build time partial evaluation. By analyzing the code, we can find
expressions that evaluate to constants or do a consistent thing and figure out
how to evaluate that ahead of time.

A second approach is to do the work once and then take a snapshot of the program
state and somehow restore it later. In normal hosts, this is very difficult
unless the language runtime has a compacting garbage collector (which Python
does not have). However, WebAssembly has a fundamentally different security
model than normal architectures and has no need for security features like
Address Space Layout Randomization that ordinarily make snapshots very hard.

Cloudflare is using Pyodide to support Python in their workers runtime and they
care a tremendous amount about startup time. I (Hood Chatham) implemented memory
snapshot support for Pyodide downstream in
[workerd](https://github.com/cloudflare/workerd) as part of my work for them.

Memory snapshots are a complex feature with tricky interactions with dynamic
linking, with ctypes, with the file system, the foreign function interface, and
with all systems that make use of entropy. Each one of these systems requires
careful design work to support well. We believe that we understand how to handle
the interactions with each of these features, but it takes time to implement.

I have upstreamed part of this work. There is no public API yet, and there are a
lot of features that do not work correctly yet. Hopefully by the end of the year
we will have something that is usable by the public. This should lead to a huge
reduction in startup time, particularly on page reloads when the memory snapshot
is cached or in node.

## Foreign function interface improvements

We started to address several long standing paper cuts involving conversion of
dictionaries in the foreign function interface. Now `toJs` of a dictionary
returns a `LiteralMap`. Any key which is a string and a valid JavaScript
identifier can be looked up by direct indexing `a.key`, in addition to being
able to look up the keys with `.get` as before. `Map` methods shadow keys
though, so if the JavaScript `Map` class gains more methods, it may cause minor
breakages.

For instance, in order to use JS `fetch` method in Python, previously you need
to do something like this:

```python
from js import fetch, Object
from pyodide.ffi import to_js

async def python_fetch(url, options: dict[str, str]):
    return await fetch(url, to_js(options, dict_converter=Object.fromEntries))
```

Here, `dict_converter` is a function that converts a Python dict to a JS object.
This was necessary because `fetch` expects a JS object as its second argument.
If `to_js` is used without `dict_converter`, the Python dict will be converted
to a JS Map, which fetch does not expect.

Now, by introducing the `LiteralMap`, the above code can be simplified to:

```python
await fetch(url, to_js(options))
```

without the need to specify `dict_converter` (thanks to Andrea Giammarchi
(@WebReflection) for the idea and implementation of `LiteralMap`).

Note that we still need to use `to_js` to convert the `options` dict to a JS
object, meaning that the following case will still not work. But we hope to
support this in the future.

```python
await fetch("example.com", options={"headers": {"a": "b"}});
```

For a similar purpose of adapting from Python JSON to JavaScript JSON without
doing a conversion we added `PyProxy.asJsJson()`. For example the following code
works now:
```js
const jsonStr1 = `{"a":[1,2,3,{"b":7}]}`;
const pyjsonmod = pyodide.pyimport("json");
const pyjson = pyjsonmod.loads(jsonStr1).asJsJson();
const jsonStr2 = JSON.stringify(pyjson);
console.log(jsonStr1 === jsonStr2); // true 
```
In future work, we intend to also add `JsProxy.as_py_json()` to do the reverse.

## Future work on the Foreign Function interface

We believe that we have pushed our current approach to the foreign function
interface about as far as it can go. We have the following requirements, in
roughly decreasing order of importance: 

1. We want every interaction with nearly every single language construct of
   JavaScript to be expressible in Python and conversely every language
   construct in Python to be expressible in JavaScript.
2. We want it to be possible and reasonably ergonomic to manage memory so that
   leaks can be avoided, which is particularly important for applications that
   do video processing like games where we cannot afford to leaking large
   buffers.
3. We want the interaction to be fast.
4. We want the interaction to be ergonomic, particularly when calling from
   Python into JavaScript.

I think we have succeeded pretty completely at goals 1 and 2. Goal 4 we have
also done a great job at, but there are corner cases most which are very
difficult to handle without compromising our more important goals. Of the four
goals, I think the performance is in the worst shape.

Compared to ctypes and most other foreign function interfaces, one thing that is
slightly unusual about Pyodide's foreign function interface is that it does not
require any metadata about what function is being called and what it means. This
causes difficulties with speed and usability that are very difficult to fix.

To solve this, we are introducing a way to tell Pyodide what the Python function
means. The beginnings of this work are included in Pyodide 0.26 but there are no
publically visible changes yet.

Hopefully we'll write a blog post discussing the design of this system in more
detail, since there is too much to say in this post. But here are a couple quick
examples. 

The following doesn't work because we forgot to say `Response.new`:
```js
Response("", status=404, statusText="Not found")
```
The following generates an empty response body:
```js
Response.json({"a": [1, 2, 3]}, status=200, statusText="Success")
```
If we bind a signature to `Response` to tell Pyodide about its shape, we these
two calls will work. This looks roughly as follows:
```py
class Response_sig:
   def __init__(self, body: Any, /, *, status: int = 200, statusText: str = "Okay"):
       pass

   @staticmethod
   def json(obj: Json, /, *, status: int = 200, statusText: str = "Okay"):
       pass

Response = Response.bind(Response_sig)
```




## pygame-ce Support

We are thrilled to announce that Pyodide now supports Pygame Community Edition
(pygame-ce). While we began supporting SDL-based graphics libraries in Pyodide
0.23.0, this release enhances the stability and compatibility of SDL libraries
within Pyodide by adding support for pygame-ce.

As an alternative to Pyodide, pygame-ce offers its own way to run pygame
applications in the browser called [pygame-web](https://github.com/pygame-web).
If your Python application relies solely on pygame-ce, pygame-web might provide
better performance. If you require a wider range of packages, you will likely
need to use Pyodide.

We would like to thank the pygame-ce maintainers, especially to Paul m. p. peny
(@pmp-p), for helping us integrate pygame-ce into Pyodide. They have been
working hard on this project for many years.

This [demo page](https://ryanking13.github.io/pyodide-pygame-demo/) provides
examples of pygame-ce running in the browser using Pyodide.

<img src="pygame-demo-output.webp" alt="Pygame aliens game demo in Pyodide" />

## Acknowledgements

Thanks to Andrea Giammarchi for the `LiteralMap` contribution. Thanks to Agriya
Khetarpal, Loïc Estève, and Ralph Gommers for their work helping ensure scientific Python
packages are well supported in Pyodide.

Thanks to Henry Schreiner, Joe Rickerby, Martin Renou, Matthieu Darbois, and
Grzegorz Bokota for their help with the cibuildwheel port. Thanks also to Henry
for helping us with our compliance with packaging standards.

Additionally, we always appreciate the support and assistance from the
Emscripten team.

Thanks to Lukasz Langha, Antonio Cuny, Eric Snow, Kushal Das, Mark Shannon,
Russel Keith-Macgee, Jeff Smith, Mike Fiedler, and many others for useful
conversations at PyCon and constructive engagement with Pyodide.

Thanks to Nicholas Tollervey and Fabio Pliger for organizing the Pycon Wasm
summit.

The following people commited to Pyodide in this release:

Brian "bits" Olsen, Christian Clauss, chrysn, C. Titus Brown, David Contreras, 
Emil Nikolov, goulashsoup, guangwu, Gyeongjae Choi, Henry Schreiner, 
Hood Chatham, Ian Thomas, ifduyue, James J Balamuta, Joel Ostblom, Joe Marshall, 
John Wason, Loïc Estève, Matthias Hochsteger, Matthias Köppe, Myles Scolnick,
Philipp Schiele, Pierre Haessig, pyodide-pr-bot, Raymond Berger, Sam Estep,
Szabolcs Dombi, Victor Blomqvist, Yuichiro Tachibana (Tsuchiya), Zsolt 
