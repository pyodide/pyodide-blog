---
title: "0"
date: 2024-05-13T11:00:55-04:00
draft: true
tags: ["announcement"]
# author: "Me"
author: ["Hood Chatham", "Gyeongjae Choi"] # multiple authors
showToc: true
TocOpen: false
draft: false
hidemeta: false
comments: false
# canonicalURL: "https://canonical.url/to/page"
disableHLJS: true # to disable highlightjs
disableShare: false
hideSummary: false
searchHidden: true
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
cover:
    # image: "<image path/url>" # image path/url
    # alt: "<alt text>" # alt text
    # caption: "<text>" # display caption under cover
    relative: false # when using page bundles set this to true
    hidden: true # only hide on current single page
---

Pyodide v0.26.0 is out with Python 3.12. We made a lot of minor improvements to
the FFI and to the build system, and we made major improvements to stack
switching support. Most of the changes we made for this release are forward
looking, either nonfunctional work on maintenance, or functional work that is
still not exposed to the end user.

## Package build system

We have made significant progress in separating our package build system
(`pyodide-build`) from the Pyodide runtime. This change will not be
obviously noticeable to regular Pyodide users, it is a crucial improvement for
several reasons:

1. __Faster Package Updates__:

Currently, pyodide-build is released in conjunction with the Pyodide runtime and
the Pyodide foreign function interface, with a quarterly release cadence. This
is inconvenient for users building packages out-of-tree because they have to
wait months to use new features or bug fixes in pyodide-build. Decoupling
pyodide-build from Pyodide runtime releases will allow us to make improvements
available faster.

2. __Faster and Easier Runtime and FFI Releases__:

Because packages can only be updated once a quarter, whenever we feel that we
are ready to release a set of changes to the runtime and foreign function
interface, we feel the need to try to update as many packages as possible so
that people won't have to wait even longer to get new stable package versions.
This significantly delays releases.

3. __Decoupling Versions__: 

`pyodide-build` and the Pyodide runtime were tightly coupled, requiring users to
match their versions to build packages. This prevented users of older Pyodide
runtimes from benefiting from improvements in pyodide-build. With this change,
users will have more flexibility to use the latest version of pyodide-build.

4. __Capacity for More Packages__:

The 250+ packages in the Pyodide distribution are rebuilt with every new commit
to Pyodide. This is a heavy burden on our CI system and makes it challenging to
support additional large packages. If we had to pay for our CI resources, we
would pay over $3,000 per month. CircleCI generously donates much more to us
than they claim they are willing to.

By separating pyodide-build and the package recipes from the Pyodide runtime, we
will be able to build packages independently, allowing us to include many more
packages in the Pyodide ecosystem. It will also make the ecosystem more
sustainable in its consumption of both computational power and maintenance
effort. As part of this effort, many scientific Python packages are now building
wheels targeting Pyodide in their repositories. Thanks to Agriya Khetarpal
(@agriyakhetarpal) and Ralf Gommers (@rgommers) for this effort and thanks to
their employer Quansight for funding the work. We are also in the process of
adding Pyodide targets to cibuildwheel, which should make it much easier for
package maintainers to build wheels for Pyodide. 

[The pull request](https://github.com/pypa/cibuildwheel/pull/1456) implementing
Pyodide support in cibuildwheel has been open for 14 months and currently has 3
contributors, 175 comments from 10 people, and has been through about five
rounds of review. It feels like we are close to merging it, which will be an
incredible milestone for Pyodide. We could hardly have imagined getting to where
we are now when we took over the Pyodide project from Mozilla in April of 2021.

This work is not yet complete, but we believe it will be done by the end of the
year.

## Improved documentation automation maintainability

We did a major rewrite of part of `sphinx-js`, moving the logic for ingesting the
typedoc ast from Python to JavaScript. In the process of doing this we discovered
and fixed a large number of bugs. It is now dramatically easier to implement new
features and to update dependencies than it ever was before. We were able to fix
most of the remaining complaints we had about the rendering of Pyodide's JS API
docs. (The content itself still has a lot of issues though.)

## Improvements to Stack Switching Support

We fixed quite a few memory leaks involving stack switching, improved the
interactions with certain other language features, and polished the API.

We removed `pyodide.runPythonSyncifying` and just automatically turn on stack
switching when calling `runPythonAsync` or any `async` Python function. We also
renamed the method that switches stacks from `syncify` to `run_sync`.

Stack switching is ready for real-world use at this point. There are a lot of
usability improvements left to build. Chrome has started the 
[JSPI origin trial](https://developer.chrome.com/blog/webassembly-jspi-origin-trial)
so if you want to use it in your web app you can add your domain to the origin trial.

## Memory snapshots



We implemented memory snapshots downstream to use with Cloudflare's Python
workers. We upstreamed part of this work. There is no stable API yet, and there
are a lot of features that do not work correctly yet. We know how to fix these
features, it just requires time. This should lead to a huge reduction in startup
time, particularly on page reloads when the memory snapshot is cached.

## Foreign function interface improvements

We started to address several long standing paper cuts involving conversion of
dictionaries in the foreign function interface. Now `toJs` of a dictionary
returns a `LiteralMap`. Any key which is a string and a valid JavaScript
identifier can be looked up by direct indexing `a.key`, in addition to being
able to look up the keys with `.get` as before. `Map` methods shadow keys
though, so if the JavaScript `Map` class gains more methods, it may cause minor
breakages.

For instance, in order to use JS `fetch` method in Python, previously you need
to do something like this:

```python
from js import fetch, Object
from pyodide.ffi import to_js

async def python_fetch(url, options: dict[str, str]):
    return await fetch(url, to_js(options, dict_converter=Object.fromEntries))
```

Here, `dict_converter` is a function that converts a Python dict to a JS object.
This was necessary because `fetch` expects a JS object as its second argument.
If `to_js` is used without `dict_converter`, the Python dict will be converted
to a JS Map, which fetch does not expect.

Now, by introducing the `LiteralMap`, the above code can be simplified to:

```python
await fetch(url, to_js(options))
```

without the need to specify `dict_converter` (thanks to Andrea Giammarchi
(@WebReflection) for the idea and implementation of `LiteralMap`).

Note that we still need to use `to_js` to convert the `options` dict to a JS
object, meaning that the following case will still not work. But we hope to
support this in the future.

```python
await fetch("example.com", options={"headers": {"a": "b"}});
```

For a similar purpose of adapting from Python JSON to JavaScript JSON without
doing a conversion we added `PyProxy.asJsJson()`. For example the following code
works now:
```js
const jsonStr1 = `{"a":[1,2,3,{"b":7}]}`;
const pyjsonmod = pyodide.pyimport("json");
const pyjson = pyjsonmod.loads(jsonStr1).asJsJson();
const jsonStr2 = JSON.stringify(pyjson);
console.log(jsonStr1 === jsonStr2); // true 
```
In future work, we intend to also add `JsProxy.as_py_json()` to do the reverse.

## pygame-ce Support

We are thrilled to announce that Pyodide now supports Pygame Community Edition
(pygame-ce). While we began supporting SDL-based graphics libraries in Pyodide
0.23.0, this release enhances the stability and compatibility of SDL libraries
within Pyodide by adding support for pygame-ce.

As an alternative to Pyodide, pygame-ce offers its own way to run pygame
applications in the browser called [pygame-web](https://github.com/pygame-web).
If your Python application relies solely on pygame-ce, pygame-web might provide
better performance. If you require a wider range of packages, you will likely
need to use Pyodide.

We would like to thank the pygame-ce maintainers, especially to Paul m. p. peny
(@pmp-p), for helping us integrate pygame-ce into Pyodide. They have been
working hard on this project for many years.

This [demo page](https://ryanking13.github.io/pyodide-pygame-demo/) provides
examples of pygame-ce running in the browser using Pyodide.

<img src="pygame-demo-output.webp" alt="Pygame aliens game demo in Pyodide" />

## Acknowledgements

Thanks to Andrea Giammarchi for the `LiteralMap` contribution. Thanks to Agriya
Khetarpal, Loïc Estève, and Ralph Gommers for their work helping ensure scientific Python
packages are well supported in Pyodide.

Thanks to Henry Schreiner, Joe Rickerby, Martin Renou, Matthieu Darbois, and
Grzegorz Bokota for their help with the cibuildwheel port. Thanks also to Henry
for helping us with our compliance with packaging standards.

Additionally, we always appreciate the support and assistance from the
Emscripten team.

The following people commited to Pyodide in this release:

Brian "bits" Olsen, Christian Clauss, chrysn, C. Titus Brown, David Contreras, 
Emil Nikolov, goulashsoup, guangwu, Gyeongjae Choi, Henry Schreiner, 
Hood Chatham, Ian Thomas, ifduyue, James J Balamuta, Joel Ostblom, Joe Marshall, 
John Wason, Loïc Estève, Matthias Hochsteger, Matthias Köppe, Myles Scolnick,
Philipp Schiele, Pierre Haessig, pyodide-pr-bot, Raymond Berger, Sam Estep,
Szabolcs Dombi, Victor Blomqvist, Yuichiro Tachibana (Tsuchiya), Zsolt 
